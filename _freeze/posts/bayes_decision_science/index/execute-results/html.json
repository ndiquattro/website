{
  "hash": "15935271e2df5e99b935d1917dbbf55e",
  "result": {
    "markdown": "---\ntitle: Bayes Deccision Science Translation\nauthor: \"Nick DiQuattro\"\ndate: '2021-06-17'\ndraft: true\n---\n\n\nI watched a great [talk recorded at PyData 2020 by Ravin Kumar](https://global.pydata.org/talks/149). I wanted to translate the gist of it into R using brms!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(brms)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: Rcpp\nLoading 'brms' package (version 2.20.3). Useful instructions\ncan be found by typing help('brms'). A more detailed introduction\nto the package is available through vignette('brms_overview').\n\nAttaching package: 'brms'\n\nThe following object is masked from 'package:stats':\n\n    ar\n```\n:::\n:::\n\n\nAnisha is starting a newspaper selling business. She buys papers each day for $5 and sells them for \\$7. This means the profit for a given day can be calculated with the following function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaily_profit <- function(inventory, sales) {\n  (min(sales, inventory) * 7) - (inventory * 5)\n}\n```\n:::\n\n\nLet's imagine two weeks of business, one in future we need to predict.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(20210617)\nsales_pop <- rnorm(14, 100, 20)\nlast_week <- sales_pop[1:7]\nnext_week <- sales_pop[8:14]\n```\n:::\n\n\nNow we need a function that will calculate profit for a week.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweeks_profit <- function(inventory, demands) {\n  map_dbl(demands, ~daily_profit(inventory, .x)) %>% sum()\n}\n```\n:::\n\n\nLet's try just taking the mean of last week to predict next week\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(last_week)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 102.6488\n```\n:::\n\n```{.r .cell-code}\nweeks_profit(round(mean(last_week)), next_week)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 610.5271\n```\n:::\n:::\n\n\nAlright, now let's fit a bayes model and see if it can do better\n\n::: {.cell}\n\n```{.r .cell-code}\ndemands_model <-\n  brm(\n    sales ~ 1,\n    data = tibble(sales = last_week),\n    prior = c(\n      prior(normal(110, 10), class = \"Intercept\"),\n      prior(exponential(1),  class = \"sigma\")\n    ),\n    silent = 2,\n    refresh = 0,\n  )\n\ndemands_model\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: sales ~ 1 \n   Data: tibble(sales = last_week) (Number of observations: 7) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nPopulation-Level Effects: \n          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nIntercept   103.80      3.72    96.69   111.39 1.00     2559     1984\n\nFamily Specific Parameters: \n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma    10.50      1.68     7.77    14.27 1.00     2744     2550\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n:::\n\n\nNow instead of just a single mean, we have a distribution of potential values to simulate over.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbayes_demands <- predict(demands_model, data.frame(r = 1), summary = FALSE)[, 1]\n\nggplot(tibble(bayes_demands = bayes_demands), aes(bayes_demands)) +\n  geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbayes_opt <-\n  optimize(\n    f = weeks_profit,\n    demands = bayes_demands,\n    interval = c(0, 500),\n    maximum = TRUE\n  )\n\nbayes_opt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$maximum\n[1] 97.37455\n\n$objective\n[1] 720974\n```\n:::\n:::\n\n\nNow let's test it on the theortical next week.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweeks_profit(round(bayes_opt$maximum), next_week)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 709.8062\n```\n:::\n:::\n\n\nCool, we have made more money! Here's just using the mean for comparison:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweeks_profit(round(mean(last_week)), next_week)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 610.5271\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}